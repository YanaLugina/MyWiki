# Cluster

Один экземпляр Node.js запускает только один поток.

Поскольку один экземпляр Node.js запускает только один поток event loop, необходимо использовать cluster, чтобы
максимально использовать возможности многоядерного сервера и запустить на каждом ядре кластер процессов Node.js для обработки нагрузки. 

Такая возможность относится только к master процессу, у которого нет уникального ID, то есть process.env.NODE_UNIQUE_ID is
undefined. Модуль cluster содержит следующую проверку на наличие данной переменной:

```javascript
const childOrMaster = 'NODE_UNIQUE_ID' in process.env ? 'child' : 'master';
module.exports = require(`internal/cluster/${childOrMaster}`);
```

Cluster используется для создания дочерних процессов worker process по одному на каждое ядро. Созданные процессы-потомки используют один и тот же порт сервера, используя циклическую балансировку нагрузки, встроенную в Node.js.

Пример создания кластера worker-процессов:

```javascript
const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  console.log(`Master ${process.pid} is running`);

  // Fork workers.
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  cluster.on('exit', (worker, code, signal) => {
    console.log(`worker ${worker.process.pid} died`);
  });
} else {
  // Workers can share any TCP connection
  // In this case it is an HTTP server
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end('hello world\n');
  }).listen(8000);

  console.log(`Worker ${process.pid} started`);
}

```

Запуск Node.js теперь разделит порт 8000 между worker'ами.

 ```javascript
$ node server.js
Master 3596 is running
Worker 4324 started
Worker 4520 started
Worker 6056 started
Worker 5644 started
```

На Windows пока невозможно именовать каналы worker'а.

Разница между cluster.fork() и child_process.fork() заключается в том, что кластер позволяет разделить TCP-серверы между worker'ами. cluster.fork реализуется поверх child_process.fork. API передачи сообщений, который доступен с child_process.fork также доступен с cluster. Например, вот кластер, который ведет подсчет количества запросов в лавном процессе посредством передачи сообщений:

```js
const cluster = require('cluster');
const http = require('http');


if (cluster.isMaster) {
    
    // Отслеживаем http-запросы
  let numReqs = 0;

    // Плодим workers.
  for (let i = 0; i < 2; i++) {
    const worker = cluster.fork();

    worker.on('message', (msg) => {
      if (msg.cmd && msg.cmd == 'notifyRequest') {
        numReqs++;
      }
    });
  }

  setInterval(() => {
    console.log("numReqs =", numReqs);
  }, 1000);
} else {
  // Worker имеют http-сервер.
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end("hello world\n");
    // Отправляем сообщение в мастер-процесс
    process.send({ cmd: 'notifyRequest' });
  }).listen(8000);
}
```

## Как это работает

Worker'ы порождаются с использованием метода child_process.fork(), так что они могут связываться с родителем по IPC и передавать серверные обработчики событий вперед и назад.

Модуль кластера содержит два метода распределения входящих соединений.

Первый метод (и используемый по умолчанию на всех платформах, кроме windows) - это циклический подход, при котором главный процесс прослушивает порт, принимая новые подключения и распределяет их между worker'ами в режиме циклического перебора, с некоторым встроенным умным распределением нагрузки, чтобы избежать перегрузку рабочего процесса.

Второй подход - где мастер-процесс создает сокет прослушивания и отправляет его заинтересованным рабочим процессам. Затем worker'ы принимают входящие подключения напрямую.

Второй подход, в теории, должен работать эффективнее. Тем не менее, на практике, такое распределение нагрузки ведет себя очень не сбалансировано, из-за капризов планировщика операционной системы. Наблюдалось распределение нагрузки, где более 70% всех соединений приходились всего на два worker-процесса из восьми.

Так как server.listen() большую часть работы передает мастер-процессу, существуют три случая, когда поведение между обычным процессом Node.js и worker-процессом кластера отличается:

 1. ```server.listen({fd: 7})``` Так как сообщения передается в мастер-процесс, дескриптор файла 7 будет прослушиваться в родительском процессе, а обработчик передаваться в worker, вместо прослушивания идея worker'а только иметь ссылки на дескриптор файла.

 2. ```server.listen(handle)``` Прослушивание обработчика в явном виде заставит рабочий процесс использовать предоставленный обработчик, а не общаться с главным процессом.

 3. ```server.listen(0)``` Обычно, таким образом вызывают прослушку случайного порта сервером. Однако, в кластере каждый работник будет получать тот же "случайный" порт каждый раз, когда получит listen(0). По сути, случайным порт будет только в первый раз, но предсказуемым впоследствии. Чтобы прослушивать уникальный порт и впоследствии, создайте номер порта на основе идентификатора worker'а кластера.

Node.js не предоставляет логику маршрутизации. Поэтому важно спроектировать приложение таким образом, чтобы оно не слишком сильно зависело от объектов данных в памяти для таких вещей, как сеансы и вход в систему.

Так как workers разбивают между собой отдельные процессы, они могут быть убиты или пересозданы в зависимости от потребностей программы, не затрагивая остальные workers. Пока хотя бы один из worker'ов жив, сервер будет продолжать принимать подключения. Если не осталось ни одного живого worker'а, существующие соединения сбросятся и запросы на новые соединения будут отклонены. Однако, Node.js автоматически не управляет количеством рабочих процессов. Приложение само несет ответственность за управление пулом workers, на основе собственных потребностей.

